<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dify</title>
    <link href="/2025/03/29/dify/"/>
    <url>/2025/03/29/dify/</url>
    
    <content type="html"><![CDATA[<p>本次毕业设计中，我用到了本地大模型管理工具Dify来实现AI工作流、RAG管道、模型管理和可观测性功能的实现。具体部署步骤如下：</p><h3 id="1-安装Dify"><a href="#1-安装Dify" class="headerlink" title="1. 安装Dify"></a>1. 安装Dify</h3><p>安装前提：电脑中有可以正确启动的Docker desktop</p><img src="/2025/03/29/dify/1.png" class=""><p><img src="D:\Desktop\Project\blog\hexo-blog\source_posts\dify\1.png"></p><p>1.1 将Dify项目从github克隆下来</p><p>项目url：<a href="https://github.com/langgenius/dify">https://github.com/langgenius/dify</a></p><p>找一个文件夹，不推荐c盘，在当前目录下使用Git命令行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">// 这种克隆要求电脑上配置了git秘钥，推荐这种<br>git clone git@github.com:langgenius/dify.git<br>// 直接从url克隆，可能会有神秘力量的阻拦导致下载失败<br>git clone https://github.com/langgenius/dify.git<br></code></pre></td></tr></table></figure><img src="/2025/03/29/dify/2.png" class=""><p>1.2 在当前目录下通过docker compose启动Dify服务器</p><p>在当前目录下继续使用Git命令行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">cd</span> dify<br><span class="hljs-built_in">cd</span> docker<br>cp .env.example .env<br>docker compose up -d<br></code></pre></td></tr></table></figure><p>命令执行后会自动下载启动Dify服务器需要用到的镜像并compose在一起，下载完毕后启动docker desktop，会显示容器已经下载好了</p><img src="/2025/03/29/dify/3.png" class=""><p>1.3 运行容器后，访问 <a href="http://localhost/install">http://localhost:/install</a></p><img src="/2025/03/29/dify/4.png" class=""><p>至此，Dify安装完成</p><h3 id="2-ollama下载大模型-（windows系统）"><a href="#2-ollama下载大模型-（windows系统）" class="headerlink" title="2. ollama下载大模型 （windows系统）"></a>2. ollama下载大模型 （windows系统）</h3><p>2.1 点击链接下载ollama</p><p><a href="https://ollama.com/download">Download Ollama on Windows</a></p><img src="/2025/03/29/dify/5.png" class=""><p>一路下一步就可以了，有必要可以通过环境变量设置ollama模型下载的目录，节省c盘空间</p><img src="/2025/03/29/dify/6.png" class=""><p>2.2 启动ollama服务</p><p>安装好之后，点击ollama文件夹中的这个exe文件，启动ollama服务</p><img src="/2025/03/29/dify/7.png" class=""><p>启动后任务栏会有一个ollama的小图标</p><img src="/2025/03/29/dify/8.png" class=""><p>cmd中输入 ollama -v</p><img src="/2025/03/29/dify/9.png" class=""><p>出现版本号代表ollama启动成功</p><p>2.3 通过ollama下载大模型</p><p>打开cmd，命令行输入 ollama run deepseek-r1:7b，下载好后使用ollama list指令可以查看已经下载好的本地大模型</p><img src="/2025/03/29/dify/10.png" class=""><p>这里选择下载大语言模型deepseek-r1:7b和嵌入模型nomic-embed-text，命令行输入为 ollama pull nomic-embed-text</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd">// 下载deepseek-r1模型<br>ollama run deepseek-r1:<span class="hljs-number">7</span>b<br>// 下载嵌入模型<br>ollama pull nomic-embed-text<br>// 查看模型<br>ollama list<br></code></pre></td></tr></table></figure><p>下载完之后可以使用ollama run+模型名称来测试能否正常运行</p><img src="/2025/03/29/dify/11.png" class=""><h3 id="3-Dify配置大模型"><a href="#3-Dify配置大模型" class="headerlink" title="3. Dify配置大模型"></a>3. Dify配置大模型</h3><p>3.1 创建AI工作流</p><p>工作台创建空白应用，选择Chatflow</p><img src="/2025/03/29/dify/12.png" class=""><p>3.2 编辑工作流</p><p>创建好之后，点击进入编辑工作流</p><img src="/2025/03/29/dify/13.png" class=""><p>具体如何编辑可以查看Dify的文档</p><p>3.3 建立知识库</p><p>顶部导航栏选择知识库，创建空白知识库后导入文件</p><img src="/2025/03/29/dify/14.png" class=""><p>3.4 知识库设置</p><p>左侧栏点击最下面的齿轮，设置知识库索引模式和检索方法</p><p>索引模式选择高质量，选用之前下载好的ollama的嵌入模型（先在右上角设置里接入ollama API）右上角设置-&gt;模型供应商-&gt;ollama 下载即可</p><img src="/2025/03/29/dify/15.png" class=""><p>reranker模型选用，可以提高文档检索的精确度</p><p>3.5 测试应用</p><p>设置好之后，在编辑工作流页面发布新应用并运行</p><img src="/2025/03/29/dify/16.png" class=""><p>文档召回测试</p><img src="/2025/03/29/dify/17.png" class="">]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker迁移</title>
    <link href="/2025/03/14/docker%E8%BF%81%E7%A7%BB/"/>
    <url>/2025/03/14/docker%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p>Docker数据一般存储在C盘，但主要数据其实是存储在WSL2的虚拟硬盘里，因为Docker Desktop依赖于WSL2以实现在windows上运行linux容器。</p><h5 id="1-停止docker服务和WSL"><a href="#1-停止docker服务和WSL" class="headerlink" title="1. 停止docker服务和WSL"></a>1. 停止docker服务和WSL</h5><ol><li><p>退出docker（docker desktop）图标下的Quit Docker Desktop</p></li><li><p>管理员身份打开PowerShell，执行wsl –shutdown关闭所有wsl实例</p></li></ol><img src="/2025/03/14/docker%E8%BF%81%E7%A7%BB/1.png" class=""><h5 id="2-导出WSL发行版"><a href="#2-导出WSL发行版" class="headerlink" title="2. 导出WSL发行版"></a>2. 导出WSL发行版</h5><p>在4.30版本及以后，在运行<a href="https://so.csdn.net/so/search?q=wsl&spm=1001.2101.3001.7020">wsl</a> -l -v时只有docker-desktop只有这一项，因为在此版本之后已经将docker-desktop与docker-desktop-data进行了合并</p><p>导出 docker-desktop到临时文件夹</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--export</span> docker<span class="hljs-literal">-desktop</span> <span class="hljs-string">&quot;C:\temp\docker-desktop.tar&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-注销原有发行版"><a href="#3-注销原有发行版" class="headerlink" title="3. 注销原有发行版"></a>3. 注销原有发行版</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--unregister</span> docker<span class="hljs-literal">-desktop</span><br></code></pre></td></tr></table></figure><h5 id="4-导入到新磁盘"><a href="#4-导入到新磁盘" class="headerlink" title="4. 导入到新磁盘"></a>4. 导入到新磁盘</h5><ol><li><p>创建目标目录，我的目录是“D:\docker”</p></li><li><p>导入并制定新路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--import</span> docker<span class="hljs-literal">-desktop</span> D:\docker\docker<span class="hljs-literal">-desktop</span> C:\temp\docker<span class="hljs-literal">-desktop</span>.tar <br></code></pre></td></tr></table></figure></li></ol><img src="/2025/03/14/docker%E8%BF%81%E7%A7%BB/2.png" class=""><h5 id="5-清理临时文件"><a href="#5-清理临时文件" class="headerlink" title="5. 清理临时文件"></a>5. 清理临时文件</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Remove-Item</span> <span class="hljs-string">&quot;C:\temp\docker-desktop-data.tar&quot;</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-string">&quot;C:\temp\docker-desktop.tar&quot;</span><br></code></pre></td></tr></table></figure><h5 id="6-重启Docker，更新docker的镜像路径"><a href="#6-重启Docker，更新docker的镜像路径" class="headerlink" title="6. 重启Docker，更新docker的镜像路径"></a>6. 重启Docker，更新docker的镜像路径</h5><img src="/2025/03/14/docker%E8%BF%81%E7%A7%BB/3.png" class=""><p>可以看到镜像文件已经全部被迁移过来了</p><img src="/2025/03/14/docker%E8%BF%81%E7%A7%BB/4.png" class="">]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pdf数据清洗与结构化</title>
    <link href="/2025/03/13/pdf%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96/"/>
    <url>/2025/03/13/pdf%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Dify私有化部署"><a href="#1-Dify私有化部署" class="headerlink" title="1. Dify私有化部署"></a>1. Dify私有化部署</h1><h5 id="1-docker-Desktop下载"><a href="#1-docker-Desktop下载" class="headerlink" title="1.  docker Desktop下载"></a>1.  docker Desktop下载</h5><h5 id="2-拉取Dify源码"><a href="#2-拉取Dify源码" class="headerlink" title="2.  拉取Dify源码"></a>2.  拉取Dify源码</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">git clone git@github.com:langgenius/dify.git<br><span class="hljs-built_in">cd</span> dify<br><span class="hljs-built_in">cd</span> docker<br>cp .env.example .env<br>docker compose up -d<br></code></pre></td></tr></table></figure><p>部署完之后，打开<a href="http://localhost/install">http://localhost/install</a></p><h1 id="2-MinerU部署"><a href="#2-MinerU部署" class="headerlink" title="2. MinerU部署"></a>2. MinerU部署</h1><h5 id="1-conda创建环境"><a href="#1-conda创建环境" class="headerlink" title="1. conda创建环境"></a>1. conda创建环境</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd">conda create -n MinerU python=<span class="hljs-number">3</span>.<span class="hljs-number">10</span><br>conda activate MinerU<br>pip install -U magic-pdf[full] --extra-index-url https://wheels.myhloli.com -i https://mirrors.aliyun.com/pypi/simple<br><br>// 下载完成后确认版本，版本号需要 &gt;<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br>magic-pdf --version<br></code></pre></td></tr></table></figure><h5 id="2-下载模型"><a href="#2-下载模型" class="headerlink" title="2. 下载模型"></a>2. 下载模型</h5><h6 id="2-1-从modelsope上下载"><a href="#2-1-从modelsope上下载" class="headerlink" title="2.1 从modelsope上下载"></a>2.1 从modelsope上下载</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install modelscope<br>wget https://gcore.jsdelivr.<span class="hljs-built_in">net</span>/gh/opendatalab/MinerU@master/scripts/download_models_hf.py -O download_models_hf.py<br>python download_models_hf.py<br></code></pre></td></tr></table></figure><img src="/2025/03/13/pdf%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96/1.png" class=""><h2 id="尚未完工。。。。。。"><a href="#尚未完工。。。。。。" class="headerlink" title="尚未完工。。。。。。"></a>尚未完工。。。。。。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数据处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路问题</title>
    <link href="/2025/03/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2025/03/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Dijkstra朴素版"><a href="#Dijkstra朴素版" class="headerlink" title="Dijkstra朴素版"></a>Dijkstra朴素版</h3><p><strong>dijkstra三部曲</strong>：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新minDist数组）<strong>minDist数组 用来记录 每一个节点距离源点的最小距离</strong>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v, e;<br>    cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, INT_MAX));<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        graph[x][y] = z; <span class="hljs-comment">// 迪杰斯特拉是有向图</span><br>    &#125;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++)&#123;<br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123; <span class="hljs-comment">// 找到离源点最近且未访问的点</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; minDist[j] &lt; minVal)&#123;<br>                minVal = minDist[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记该点为已访问</span><br>        visit[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 更新minDist，如果当前点集到点j的距离小于minDist，则更新dist</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; graph[cur][j] != INT_MAX &amp;&amp; minDist[cur] + graph[cur][j] &lt; minDist[j])&#123;<br>                minDist[j] = minDist[cur] + graph[cur][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[v] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[v];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2025/03/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2025/03/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h3 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h3><p>prim算法三部曲，每次寻找距离最小生成树最近的节点：</p><ul><li><p>第一步，选距离生成树最近节点</p></li><li><p>第二步，最近节点加入生成树</p></li><li><p>第三步，更新非生成树节点到最小生成树的距离（即更新minDist数组）<strong>minDist数组里记录的其实也是最小生成树的边的权值</strong></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。 </p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><p>输入：第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p><h6 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> e)</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v, e;<br>    cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        graph[x][y] = z;<br>        graph[y][x] = z; <span class="hljs-comment">// 无向图两个方向都有权重</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果要输出路径，则可以用一个parent数组记录</span><br>    <span class="hljs-comment">// vector&lt;int&gt; parent(v + 1, -1);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++)&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">// 本次加入最小生成树的节点</span><br>    <span class="hljs-type">int</span> minVal = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123; <span class="hljs-comment">// 三部曲之一：选择加入的节点</span><br>        <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; minDist[j] &lt; minVal)&#123;<br>            minVal = minDist[j];<br>            cur = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 三部曲之二：将离最小生成树最近的节点加入最小生成树</span><br>    visit[cur] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 三部曲之三：更新minDist数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= v; k++)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[k] &amp;&amp; graph[cur][k] &lt; minDist[k])<br>            minDist[k] = graph[cur][k];<br>        <span class="hljs-comment">// parent[j] = cur; // 记录边</span><br>    &#125;<br>&#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= v; i++) res += minDist[i];<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSet</span>&#123;<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化并查集</span><br><span class="hljs-built_in">DisjointSet</span>(<span class="hljs-type">int</span> n)&#123;<br>parent.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>parent[i] = i; <span class="hljs-comment">// 初始时，每个元素的父亲指向自己 </span><br>&#125;<br>&#125; <br><br><span class="hljs-comment">// 查找（路径压缩） </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(parent[x] != x)&#123;<br>parent[x] = <span class="hljs-built_in">find</span>(parent[x]); <span class="hljs-comment">// 使路径上所有节点指向根节点 </span><br>&#125; <br><span class="hljs-keyword">return</span> parent[x];<br>&#125; <br><br><span class="hljs-comment">// 判断两个元素是否在同一个集合里</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125; <br><br><span class="hljs-comment">// 合并两个集合 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isConnected</span>(x, y)) <span class="hljs-keyword">return</span>;<br>parent[<span class="hljs-built_in">find</span>(y)] = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 尤其注意合并时要用find(y)和find(x)，否则会导致合并错误 </span><br>&#125;<br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> from;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> val;<br>&#125;;<br><span class="hljs-type">int</span> index;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> v, e;<br>cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;Edge&gt; edges;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br><span class="hljs-type">int</span> x, y, z;<br>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>edges.<span class="hljs-built_in">push_back</span>(&#123;x, y, z&#125;);<br>&#125;<br><span class="hljs-comment">// 执行克鲁斯卡尔算法，每次加入一条权值最小的边，需要先对边进行排序，升序 </span><br><span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b)&#123;<br><span class="hljs-keyword">return</span> a.val &lt; b.val; <br>&#125;); <br><br><span class="hljs-function">DisjointSet <span class="hljs-title">dsu</span><span class="hljs-params">(v)</span></span>; <br><span class="hljs-type">int</span> mst_weight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最小生成树的权值 </span><br>vector&lt;Edge&gt; mst; <span class="hljs-comment">// 记录最小生成树 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge: edges)&#123;<br><span class="hljs-keyword">if</span>(!dsu.<span class="hljs-built_in">isConnected</span>(edge.from, edge.to))&#123;<br>dsu.<span class="hljs-built_in">unite</span>(edge.from, edge.to);<br>mst_weight += edge.val;<br>mst.<span class="hljs-built_in">push_back</span>(edge);<br>&#125;<br>&#125; <br><br>cout &lt;&lt; mst_weight;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs</title>
    <link href="/2025/03/05/dfs/"/>
    <url>/2025/03/05/dfs/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><ul><li><p>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</p></li><li><p>换方向是指回到上一个还有路的节点，找另外一条没走过的路径，尝试能不能达到终点。</p><p>代码框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(退出条件) <span class="hljs-keyword">return</span>;<br>    处理节点<br>    <span class="hljs-built_in">dfs</span>(图,选择的节点);<br>    回溯，撤销处理结果 <span class="hljs-comment">// 这里一般不用写，类似于二叉树的遍历，隐含了回溯。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用邻接表来实现输出任意两个节点之间的所有路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> edge_index = <span class="hljs-number">0</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 记录路径结果集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 记录路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    Edge *next; <span class="hljs-comment">// 指向下一条边结点</span><br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// 边指向的顶点</span><br>    <span class="hljs-comment">// int w;</span><br>&#125; edges[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    Edge* first; <span class="hljs-comment">// 指向第一条邻接边的指针</span><br>&#125;nodes[<span class="hljs-number">100005</span>];<br><span class="hljs-comment">// 在顶点x和顶点y之间加一条权值为z的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    edges[edge_index].to = y;<br>    <span class="hljs-comment">// edges[edge_index].w = z;</span><br>    <span class="hljs-comment">// 头插法插入新边</span><br>    edges[edge_index].next = nodes[x].first;<br>    nodes[x].first = &amp;edges[edge_index];<span class="hljs-comment">// first是指针，edges是Edge类型，所以要用&amp;取到edges的地址传给first</span><br>    edge_index++;<br>&#125;<br><span class="hljs-comment">// dfs</span><br><span class="hljs-comment">// 递归必须要有一个完整的过程，即当前顶点加入路径集-&gt;找完当前顶点的所有邻接点-&gt;回溯当前节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> target)</span></span>&#123;<br>path.<span class="hljs-built_in">push_back</span>(now);<br>    <span class="hljs-keyword">if</span>(now == target)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Edge* e = nodes[now].first;<br>    <span class="hljs-keyword">while</span>(e != <span class="hljs-literal">nullptr</span>)&#123;<br>    <span class="hljs-built_in">dfs</span>(e-&gt;to, target);<br>    e = e-&gt;next;<br>&#125;<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-comment">// 初始化所有节点的first指针</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>        nodes[i].first = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-comment">// 加边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-built_in">addEdge</span>(v1, v2);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, m); <span class="hljs-comment">// 1-m的所有路径</span><br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; res : result)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> node : res)&#123;<br>            cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法是递归算法的副产品，一般回溯算法的代码模板为：</p><p>剪枝优化：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 回溯模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以组合问题为例，其中n为元素的个数，k为组合集合元素个数，startIndex为搜索的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-comment">// 递归的出口，就是找到了一个组合</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123; <br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>    <span class="hljs-comment">// 从startIndex开始搜索，一般startIndex第一次传入为1，i &lt;= n可以改成i &lt;= n - (k - path.size()) + 1，达到剪枝效果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++)&#123;<br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 把当前搜索结果加入结果集</span><br>        <span class="hljs-built_in">backTracking</span>(n, k, i<span class="hljs-number">+1</span>) <span class="hljs-comment">// 搜索下一层可以加入结果集的结果，就是递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，穷举完剩下的所有结果</span><br>    &#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getResult</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>    <span class="hljs-built_in">backTracking</span>(n, k, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树学习</title>
    <link href="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h5 id="c-定义二叉树（链式存储）"><a href="#c-定义二叉树（链式存储）" class="headerlink" title="c++定义二叉树（链式存储）"></a>c++定义二叉树（链式存储）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>    TreeNode *left;<span class="hljs-comment">// 单独声明指针变量时，TreeNode* left和TreeNode* right等价，都是TreeNode指针类型</span><br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*访问节点顺序：中左右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用栈，每次先放根节点，再放右孩子，接着是左孩子（出栈顺序相反）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 根节点出栈</span><br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左中右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><ul><li><p>跟前序的迭代有所不同，前序是<strong>访问根然后处理根，访问和处理顺序一致，所以不好处理</strong>。</p></li><li><p>中序是左中右，要先访问到树的最左孩子才能处理节点，而访问是从根开始的，因此处理顺序和访问顺序是不同的。</p></li><li><p>处理方法：指针访问节点，栈处理节点</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 用指针访问节点，直到最左孩子，同时把节点存入栈</span><br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 对根节点的操作 中</span><br>            cur = cur-&gt;right; <span class="hljs-comment">// 右</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左右中*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    <span class="hljs-comment">//操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>与前序类似，思路为</p><img src="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/inOrder.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放结果的数组</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转result数组，得到最终结果</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业设计</title>
    <link href="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）"><a href="#基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）" class="headerlink" title="基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）"></a>基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）</h1><h2 id="1-Huggingface上下载Deepseek-r1-1-5b"><a href="#1-Huggingface上下载Deepseek-r1-1-5b" class="headerlink" title="1.Huggingface上下载Deepseek-r1:1.5b"></a>1.Huggingface上下载Deepseek-r1:1.5b</h2><h2 id="2-本地微调Deepseek"><a href="#2-本地微调Deepseek" class="headerlink" title="2.本地微调Deepseek"></a>2.本地微调Deepseek</h2><h2 id="3-合并量化后的模型导入Ollama"><a href="#3-合并量化后的模型导入Ollama" class="headerlink" title="3.合并量化后的模型导入Ollama"></a>3.合并量化后的模型导入Ollama</h2><h3 id="1-合并量化模型"><a href="#1-合并量化模型" class="headerlink" title="1.合并量化模型"></a>1.合并量化模型</h3><h5 id="1-尝试用以下代码对原始模型和LoRA权重进行合并"><a href="#1-尝试用以下代码对原始模型和LoRA权重进行合并" class="headerlink" title="1.尝试用以下代码对原始模型和LoRA权重进行合并"></a>1.尝试用以下代码对原始模型和LoRA权重进行合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载原来的模型</span><br>base_model = AutoModelForCausalLM.from_pretrained(<br>    model_path,<br>    torch_dtype=torch.bfloat16,<br>    device_map=<span class="hljs-string">&quot;auto&quot;</span><br>)<br><br><span class="hljs-comment"># 加载训练好的模型</span><br>lora_model = PeftModel.from_pretrained(<br>    base_model,<br>    output_dir<br>)<br>merged_model = lora_model.merge_and_unload()<br>merged_model.save_pretrained(merged_model_path)<br>tokenizer.save_pretrained(merged_model_path)<br></code></pre></td></tr></table></figure><p>得到以下结果：</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.1.png" class=""><h5 id="2-量化模型"><a href="#2-量化模型" class="headerlink" title="2.量化模型"></a>2.量化模型</h5><h6 id="2-1-下载ollama源码"><a href="#2-1-下载ollama源码" class="headerlink" title="2.1 下载ollama源码"></a>2.1 下载ollama源码</h6><p>移步到新文件夹，git clone <a href="https://github.com/ollama/ollama/tree/main">https://github.com/ollama/ollama/tree/main</a></p><h6 id="2-2-下载llama-cpp源码"><a href="#2-2-下载llama-cpp源码" class="headerlink" title="2.2 下载llama.cpp源码"></a>2.2 下载llama.cpp源码</h6><p>同一文件夹下，git clone <a href="https://github.com/ggerganov/llama.cpp">https://github.com/ggerganov/llama.cpp</a></p><h6 id="2-3-复制项目文件"><a href="#2-3-复制项目文件" class="headerlink" title="2.3 复制项目文件"></a>2.3 复制项目文件</h6><p>使用pycharm打开ollama文件夹，把llama.cpp文件夹移入llm文件夹中</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.3.png" class=""><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 创建虚拟环境 <br>conda create -n llama python=<span class="hljs-number">3</span>.<span class="hljs-number">11</span><br># 激活虚拟环境 <br>conda activate llama<br># 安装llama.cpp的项目依赖<br><span class="hljs-built_in">cd</span> ./llm/llama.cpp<br>pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h6 id="2-4-安装cmake和编译器"><a href="#2-4-安装cmake和编译器" class="headerlink" title="2.4 安装cmake和编译器"></a>2.4 安装cmake和编译器</h6><p>cmake官网下载.msi安装器，安装完成后验证</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.4.png" class=""><h6 id="2-5-开始编译"><a href="#2-5-开始编译" class="headerlink" title="2.5 开始编译"></a>2.5 开始编译</h6><p>在llm&#x2F;llama.cpp文件夹下开始编译</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 创建build文件夹<br><span class="hljs-built_in">mkdir</span> build<br><br># 进入build文件夹<br><span class="hljs-built_in">cd</span> build<br><br># 构建<br># 生成构建配置，解析CMakeList.txt<br>cmake ..<br># 执行编译，最终在bin中生成可执行文件<br>cmake --build . --config Release<br></code></pre></td></tr></table></figure><p>最后得到的Release文件夹中的llama.quantize.exe就是我们用来量化模型可执行文件</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.5.png" class=""><h6 id="2-6-把safttensors转化为gguf文件"><a href="#2-6-把safttensors转化为gguf文件" class="headerlink" title="2.6 把safttensors转化为gguf文件"></a>2.6 把safttensors转化为gguf文件</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python convert_hf_to_gguf.py D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model <br></code></pre></td></tr></table></figure><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.6.2.jpg" class=""><p>查看文件夹，正确得到了gguf文件</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.6.1.jpg" class=""><h6 id="2-7-量化模型"><a href="#2-7-量化模型" class="headerlink" title="2.7 量化模型"></a>2.7 量化模型</h6><p>官方提供了多种量化格式，这里用的是Q4_K_M method</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.7.1.jpg" class=""><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># bin/Release/llama-quantize </span><br><span class="hljs-attribute">llama</span>-quantize D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model\deepseek-model-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>B-F16.gguf D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model\deepseek-model-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>B-Q4_K_M.gguf Q4_K_M<br></code></pre></td></tr></table></figure><h6 id="2-8-创建Ollama模型"><a href="#2-8-创建Ollama模型" class="headerlink" title="2.8 创建Ollama模型"></a>2.8 创建Ollama模型</h6><p>创建ModelFile文件</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.8.1.jpg" class=""><p>创建模型</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ollama create deepseek-lora-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>b -f D:\Ollama\models\ModelFiles\deepseek-lora-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>b.Modelfile<br></code></pre></td></tr></table></figure><p>创建成功</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.2.8.2.jpg" class=""><h2 id="4-投喂PDF-观察效果"><a href="#4-投喂PDF-观察效果" class="headerlink" title="4.投喂PDF,观察效果"></a>4.投喂PDF,观察效果</h2><h2 id="尚未完工。。。。。。"><a href="#尚未完工。。。。。。" class="headerlink" title="尚未完工。。。。。。"></a>尚未完工。。。。。。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
