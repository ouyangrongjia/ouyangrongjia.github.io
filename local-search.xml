<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法是递归算法的副产品，一般回溯算法的代码模板为：</p><p>剪枝优化：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以组合问题为例，其中n为元素的个数，k为组合集合元素个数，startIndex为搜索的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-comment">// 递归的出口，就是找到了一个组合</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123; <br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>    <span class="hljs-comment">// 从startIndex开始搜索，一般startIndex第一次传入为1，i &lt;= n可以改成i &lt;= n - (k - path.size()) + 1，达到剪枝效果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++)&#123;<br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 把当前搜索结果加入结果集</span><br>        <span class="hljs-built_in">backTracking</span>(n, k, i<span class="hljs-number">+1</span>) <span class="hljs-comment">// 搜索下一层可以加入结果集的结果，就是递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，穷举完剩下的所有结果</span><br>    &#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getResult</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>    <span class="hljs-built_in">backTracking</span>(n, k, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树学习</title>
    <link href="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h5 id="c-定义二叉树（链式存储）"><a href="#c-定义二叉树（链式存储）" class="headerlink" title="c++定义二叉树（链式存储）"></a>c++定义二叉树（链式存储）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>    TreeNode *left;<span class="hljs-comment">// 单独声明指针变量时，TreeNode* left和TreeNode* right等价，都是TreeNode指针类型</span><br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*访问节点顺序：中左右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用栈，每次先放根节点，再放右孩子，接着是左孩子（出栈顺序相反）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 根节点出栈</span><br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左中右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><p>跟前序的迭代有所不同，前序是<strong>访问根然后处理根，访问和处理顺序一致，所以不好处理</strong>。</p><p>中序是左中右，要先访问到树的最左孩子才能处理节点，而访问是从根开始的，因此处理顺序和访问顺序是不同的。</p><p>处理方法：指针访问节点，栈处理节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 用指针访问节点，直到最左孩子，同时把节点存入栈</span><br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 对根节点的操作 中</span><br>            cur = cur-&gt;right; <span class="hljs-comment">// 右</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左右中*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    <span class="hljs-comment">//操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>与前序类似，思路为</p><img src="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/inOrder.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放结果的数组</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转result数组，得到最终结果</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业设计</title>
    <link href="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）"><a href="#基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）" class="headerlink" title="基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）"></a>基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）</h1><h2 id="1-Huggingface上下载Deepseek-r1-1-5b"><a href="#1-Huggingface上下载Deepseek-r1-1-5b" class="headerlink" title="1.Huggingface上下载Deepseek-r1:1.5b"></a>1.Huggingface上下载Deepseek-r1:1.5b</h2><h2 id="2-本地微调Deepseek"><a href="#2-本地微调Deepseek" class="headerlink" title="2.本地微调Deepseek"></a>2.本地微调Deepseek</h2><h2 id="3-合并量化后的模型导入Ollama"><a href="#3-合并量化后的模型导入Ollama" class="headerlink" title="3.合并量化后的模型导入Ollama"></a>3.合并量化后的模型导入Ollama</h2><h3 id="1-合并量化模型"><a href="#1-合并量化模型" class="headerlink" title="1.合并量化模型"></a>1.合并量化模型</h3><h5 id="1-尝试用以下代码对原始模型和LoRA权重进行合并"><a href="#1-尝试用以下代码对原始模型和LoRA权重进行合并" class="headerlink" title="1.尝试用以下代码对原始模型和LoRA权重进行合并"></a>1.尝试用以下代码对原始模型和LoRA权重进行合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载原来的模型</span><br>base_model = AutoModelForCausalLM.from_pretrained(<br>    model_path,<br>    torch_dtype=torch.bfloat16,<br>    device_map=<span class="hljs-string">&quot;auto&quot;</span><br>)<br><br><span class="hljs-comment"># 加载训练好的模型</span><br>lora_model = PeftModel.from_pretrained(<br>    base_model,<br>    output_dir<br>)<br>merged_model = lora_model.merge_and_unload()<br>merged_model.save_pretrained(merged_model_path)<br>tokenizer.save_pretrained(merged_model_path)<br></code></pre></td></tr></table></figure><p>得到以下结果：</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.1.png" class=""><h5 id="2-量化模型"><a href="#2-量化模型" class="headerlink" title="2.量化模型"></a>2.量化模型</h5><h6 id="2-1-下载ollama源码"><a href="#2-1-下载ollama源码" class="headerlink" title="2.1 下载ollama源码"></a>2.1 下载ollama源码</h6><p>移步到新文件夹，git clone <a href="https://github.com/ollama/ollama/tree/main">https://github.com/ollama/ollama/tree/main</a></p><h6 id="2-2-下载llama-cpp源码"><a href="#2-2-下载llama-cpp源码" class="headerlink" title="2.2 下载llama.cpp源码"></a>2.2 下载llama.cpp源码</h6><p>同一文件夹下，git clone <a href="https://github.com/ggerganov/llama.cpp">https://github.com/ggerganov/llama.cpp</a></p><h6 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h6><h2 id="4-投喂PDF-观察效果"><a href="#4-投喂PDF-观察效果" class="headerlink" title="4.投喂PDF,观察效果"></a>4.投喂PDF,观察效果</h2>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
