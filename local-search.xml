<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉树学习</title>
    <link href="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h5 id="c-定义二叉树（链式存储）"><a href="#c-定义二叉树（链式存储）" class="headerlink" title="c++定义二叉树（链式存储）"></a>c++定义二叉树（链式存储）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>    TreeNode *left;<span class="hljs-comment">// 单独声明指针变量时，TreeNode* left和TreeNode* right等价，都是TreeNode指针类型</span><br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*访问节点顺序：中左右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用栈，每次先放根节点，再放右孩子，接着是左孩子（出栈顺序相反）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 根节点出栈</span><br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左中右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><p>跟前序的迭代有所不同，前序是<strong>访问根然后处理根，访问和处理顺序一致，所以不好处理</strong>。</p><p>中序是左中右，要先访问到树的最左孩子才能处理节点，而访问是从根开始的，因此处理顺序和访问顺序是不同的。</p><p>处理方法：指针访问节点，栈处理节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 用指针访问节点，直到最左孩子，同时把节点存入栈</span><br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 对根节点的操作 中</span><br>            cur = cur-&gt;right; <span class="hljs-comment">// 右</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左右中*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    <span class="hljs-comment">//操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>与前序类似，思路为</p><img src="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/inOrder.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放结果的数组</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转result数组，得到最终结果</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业设计</title>
    <link href="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>基于Deepseek的问答系统</p>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
