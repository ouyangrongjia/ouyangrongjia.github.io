<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2025/03/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2025/03/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h3 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h3><p>prim算法三部曲，每次寻找距离最小生成树最近的节点：</p><ul><li><p>第一步，选距离生成树最近节点</p></li><li><p>第二步，最近节点加入生成树</p></li><li><p>第三步，更新非生成树节点到最小生成树的距离（即更新minDist数组）<strong>minDist数组里记录的其实也是最小生成树的边的权值</strong></p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。 </p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><p>输入：第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p><h6 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> e)</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v, e;<br>    cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        graph[x][y] = z;<br>        graph[y][x] = z; <span class="hljs-comment">// 无向图两个方向都有权重</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果要输出路径，则可以用一个parent数组记录</span><br>    <span class="hljs-comment">// vector&lt;int&gt; parent(v + 1, -1);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++)&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>; <span class="hljs-comment">// 本次加入最小生成树的节点</span><br>    <span class="hljs-type">int</span> minVal = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123; <span class="hljs-comment">// 三部曲之一：选择加入的节点</span><br>        <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; minDist[j] &lt; minVal)&#123;<br>            minVal = minDist[j];<br>            cur = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 三部曲之二：将离最小生成树最近的节点加入最小生成树</span><br>    visit[cur] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 三部曲之三：更新minDist数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= v; k++)&#123;<br>        <span class="hljs-keyword">if</span>(!visit[k] &amp;&amp; graph[cur][k] &lt; minDist[k])<br>            minDist[k] = graph[cur][k];<br>        <span class="hljs-comment">// parent[j] = cur; // 记录边</span><br>    &#125;<br>&#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= v; i++) res += minDist[i];<br>    cout &lt;&lt; res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSet</span>&#123;<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; parent;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化并查集</span><br><span class="hljs-built_in">DisjointSet</span>(<span class="hljs-type">int</span> n)&#123;<br>parent.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>parent[i] = i; <span class="hljs-comment">// 初始时，每个元素的父亲指向自己 </span><br>&#125;<br>&#125; <br><br><span class="hljs-comment">// 查找（路径压缩） </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(parent[x] != x)&#123;<br>parent[x] = <span class="hljs-built_in">find</span>(parent[x]); <span class="hljs-comment">// 使路径上所有节点指向根节点 </span><br>&#125; <br><span class="hljs-keyword">return</span> parent[x];<br>&#125; <br><br><span class="hljs-comment">// 判断两个元素是否在同一个集合里</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125; <br><br><span class="hljs-comment">// 合并两个集合 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isConnected</span>(x, y)) <span class="hljs-keyword">return</span>;<br>parent[<span class="hljs-built_in">find</span>(y)] = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 尤其注意合并时要用find(y)和find(x)，否则会导致合并错误 </span><br>&#125;<br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> from;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> val;<br>&#125;;<br><span class="hljs-type">int</span> index;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> v, e;<br>cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;Edge&gt; edges;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br><span class="hljs-type">int</span> x, y, z;<br>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>edges.<span class="hljs-built_in">push_back</span>(&#123;x, y, z&#125;);<br>&#125;<br><span class="hljs-comment">// 执行克鲁斯卡尔算法，每次加入一条权值最小的边，需要先对边进行排序，升序 </span><br><span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b)&#123;<br><span class="hljs-keyword">return</span> a.val &lt; b.val; <br>&#125;); <br><br><span class="hljs-function">DisjointSet <span class="hljs-title">dsu</span><span class="hljs-params">(v)</span></span>; <br><span class="hljs-type">int</span> mst_weight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最小生成树的权值 </span><br>vector&lt;Edge&gt; mst; <span class="hljs-comment">// 记录最小生成树 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edge: edges)&#123;<br><span class="hljs-keyword">if</span>(!dsu.<span class="hljs-built_in">isConnected</span>(edge.from, edge.to))&#123;<br>dsu.<span class="hljs-built_in">unite</span>(edge.from, edge.to);<br>mst_weight += edge.val;<br>mst.<span class="hljs-built_in">push_back</span>(edge);<br>&#125;<br>&#125; <br><br>cout &lt;&lt; mst_weight;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Dijkstra朴素版"><a href="#Dijkstra朴素版" class="headerlink" title="Dijkstra朴素版"></a>Dijkstra朴素版</h3><p><strong>dijkstra三部曲</strong>：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新minDist数组）<strong>minDist数组 用来记录 每一个节点距离源点的最小距离</strong>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> v, e;<br>    cin &gt;&gt; v &gt;&gt; e;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, INT_MAX));<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; i++)&#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        graph[x][y] = z; <span class="hljs-comment">// 迪杰斯特拉是有向图</span><br>    &#125;<br>    minDist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++)&#123;<br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123; <span class="hljs-comment">// 找到离源点最近且未访问的点</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; minDist[j] &lt; minVal)&#123;<br>                minVal = minDist[j];<br>                cur = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 标记该点为已访问</span><br>        visit[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 更新minDist，如果当前点集到点j的距离小于minDist，则更新dist</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; graph[cur][j] != INT_MAX &amp;&amp; minDist[cur] + graph[cur][j] &lt; minDist[j])&#123;<br>                minDist[j] = minDist[cur] + graph[cur][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minDist[v] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[v];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dfs</title>
    <link href="/2025/03/05/dfs/"/>
    <url>/2025/03/05/dfs/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><ul><li><p>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</p></li><li><p>换方向是指回到上一个还有路的节点，找另外一条没走过的路径，尝试能不能达到终点。</p><p>代码框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(退出条件) <span class="hljs-keyword">return</span>;<br>    处理节点<br>    <span class="hljs-built_in">dfs</span>(图,选择的节点);<br>    回溯，撤销处理结果 <span class="hljs-comment">// 这里一般不用写，类似于二叉树的遍历，隐含了回溯。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用邻接表来实现输出任意两个节点之间的所有路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> edge_index = <span class="hljs-number">0</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 记录路径结果集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 记录路径</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    Edge *next; <span class="hljs-comment">// 指向下一条边结点</span><br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// 边指向的顶点</span><br>    <span class="hljs-comment">// int w;</span><br>&#125; edges[<span class="hljs-number">100005</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    Edge* first; <span class="hljs-comment">// 指向第一条邻接边的指针</span><br>&#125;nodes[<span class="hljs-number">100005</span>];<br><span class="hljs-comment">// 在顶点x和顶点y之间加一条权值为z的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    edges[edge_index].to = y;<br>    <span class="hljs-comment">// edges[edge_index].w = z;</span><br>    <span class="hljs-comment">// 头插法插入新边</span><br>    edges[edge_index].next = nodes[x].first;<br>    nodes[x].first = &amp;edges[edge_index];<span class="hljs-comment">// first是指针，edges是Edge类型，所以要用&amp;取到edges的地址传给first</span><br>    edge_index++;<br>&#125;<br><span class="hljs-comment">// dfs</span><br><span class="hljs-comment">// 递归必须要有一个完整的过程，即当前顶点加入路径集-&gt;找完当前顶点的所有邻接点-&gt;回溯当前节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> target)</span></span>&#123;<br>path.<span class="hljs-built_in">push_back</span>(now);<br>    <span class="hljs-keyword">if</span>(now == target)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Edge* e = nodes[now].first;<br>    <span class="hljs-keyword">while</span>(e != <span class="hljs-literal">nullptr</span>)&#123;<br>    <span class="hljs-built_in">dfs</span>(e-&gt;to, target);<br>    e = e-&gt;next;<br>&#125;<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-comment">// 初始化所有节点的first指针</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>        nodes[i].first = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-comment">// 加边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> v1, v2;<br>        cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-built_in">addEdge</span>(v1, v2);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, m); <span class="hljs-comment">// 1-m的所有路径</span><br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; res : result)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> node : res)&#123;<br>            cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法是递归算法的副产品，一般回溯算法的代码模板为：</p><p>剪枝优化：</p><ol><li>已经选择的元素个数：path.size();</li><li>所需需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）</li><li>在集合n中至多要从该起始位置 : i &lt;&#x3D; n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 回溯模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以组合问题为例，其中n为元素的个数，k为组合集合元素个数，startIndex为搜索的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>    <span class="hljs-comment">// 递归的出口，就是找到了一个组合</span><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123; <br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>    <span class="hljs-comment">// 从startIndex开始搜索，一般startIndex第一次传入为1，i &lt;= n可以改成i &lt;= n - (k - path.size()) + 1，达到剪枝效果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++)&#123;<br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 把当前搜索结果加入结果集</span><br>        <span class="hljs-built_in">backTracking</span>(n, k, i<span class="hljs-number">+1</span>) <span class="hljs-comment">// 搜索下一层可以加入结果集的结果，就是递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，穷举完剩下的所有结果</span><br>    &#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getResult</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>    <span class="hljs-built_in">backTracking</span>(n, k, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树学习</title>
    <link href="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h5 id="c-定义二叉树（链式存储）"><a href="#c-定义二叉树（链式存储）" class="headerlink" title="c++定义二叉树（链式存储）"></a>c++定义二叉树（链式存储）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>    TreeNode *left;<span class="hljs-comment">// 单独声明指针变量时，TreeNode* left和TreeNode* right等价，都是TreeNode指针类型</span><br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><h5 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*访问节点顺序：中左右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用栈，每次先放根节点，再放右孩子，接着是左孩子（出栈顺序相反）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 根节点出栈</span><br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左中右*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><ul><li><p>跟前序的迭代有所不同，前序是<strong>访问根然后处理根，访问和处理顺序一致，所以不好处理</strong>。</p></li><li><p>中序是左中右，要先访问到树的最左孩子才能处理节点，而访问是从根开始的，因此处理顺序和访问顺序是不同的。</p></li><li><p>处理方法：指针访问节点，栈处理节点</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    TreeNode* cur = root;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)&#123;<br>            st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 用指针访问节点，直到最左孩子，同时把节点存入栈</span><br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 对根节点的操作 中</span><br>            cur = cur-&gt;right; <span class="hljs-comment">// 右</span><br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*左右中*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    <span class="hljs-comment">//操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h5><p>与前序类似，思路为</p><img src="/2025/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/inOrder.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    stack&lt;TreeNode*&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 存放结果的数组</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 对根节点的操作</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 翻转result数组，得到最终结果</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业设计</title>
    <link href="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）"><a href="#基于Deepseek的问答系统（本地部署-微调-可视化问答系统-pdf投喂）" class="headerlink" title="基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）"></a>基于Deepseek的问答系统（本地部署+微调+可视化问答系统+pdf投喂）</h1><h2 id="1-Huggingface上下载Deepseek-r1-1-5b"><a href="#1-Huggingface上下载Deepseek-r1-1-5b" class="headerlink" title="1.Huggingface上下载Deepseek-r1:1.5b"></a>1.Huggingface上下载Deepseek-r1:1.5b</h2><h2 id="2-本地微调Deepseek"><a href="#2-本地微调Deepseek" class="headerlink" title="2.本地微调Deepseek"></a>2.本地微调Deepseek</h2><h2 id="3-合并量化后的模型导入Ollama"><a href="#3-合并量化后的模型导入Ollama" class="headerlink" title="3.合并量化后的模型导入Ollama"></a>3.合并量化后的模型导入Ollama</h2><h3 id="1-合并量化模型"><a href="#1-合并量化模型" class="headerlink" title="1.合并量化模型"></a>1.合并量化模型</h3><h5 id="1-尝试用以下代码对原始模型和LoRA权重进行合并"><a href="#1-尝试用以下代码对原始模型和LoRA权重进行合并" class="headerlink" title="1.尝试用以下代码对原始模型和LoRA权重进行合并"></a>1.尝试用以下代码对原始模型和LoRA权重进行合并</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载原来的模型</span><br>base_model = AutoModelForCausalLM.from_pretrained(<br>    model_path,<br>    torch_dtype=torch.bfloat16,<br>    device_map=<span class="hljs-string">&quot;auto&quot;</span><br>)<br><br><span class="hljs-comment"># 加载训练好的模型</span><br>lora_model = PeftModel.from_pretrained(<br>    base_model,<br>    output_dir<br>)<br>merged_model = lora_model.merge_and_unload()<br>merged_model.save_pretrained(merged_model_path)<br>tokenizer.save_pretrained(merged_model_path)<br></code></pre></td></tr></table></figure><p>得到以下结果：</p><img src="/2025/02/27/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2.1.png" class=""><h5 id="2-量化模型"><a href="#2-量化模型" class="headerlink" title="2.量化模型"></a>2.量化模型</h5><h6 id="2-1-下载ollama源码"><a href="#2-1-下载ollama源码" class="headerlink" title="2.1 下载ollama源码"></a>2.1 下载ollama源码</h6><p>移步到新文件夹，git clone <a href="https://github.com/ollama/ollama/tree/main">https://github.com/ollama/ollama/tree/main</a></p><h6 id="2-2-下载llama-cpp源码"><a href="#2-2-下载llama-cpp源码" class="headerlink" title="2.2 下载llama.cpp源码"></a>2.2 下载llama.cpp源码</h6><p>同一文件夹下，git clone <a href="https://github.com/ggerganov/llama.cpp">https://github.com/ggerganov/llama.cpp</a></p><h6 id="2-3-复制项目文件"><a href="#2-3-复制项目文件" class="headerlink" title="2.3 复制项目文件"></a>2.3 复制项目文件</h6><p>使用pycharm打开ollama文件夹，把llama.cpp文件夹移入llm文件夹中</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 创建虚拟环境 <br>conda create -n llama python=<span class="hljs-number">3</span>.<span class="hljs-number">11</span><br># 激活虚拟环境 <br>conda activate llama<br># 安装llama.cpp的项目依赖<br><span class="hljs-built_in">cd</span> ./llm/llama.cpp<br>pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h6 id="2-4-安装cmake和编译器"><a href="#2-4-安装cmake和编译器" class="headerlink" title="2.4 安装cmake和编译器"></a>2.4 安装cmake和编译器</h6><p>cmake官网下载.msi安装器，安装完成后验证</p><h6 id="2-5-开始编译"><a href="#2-5-开始编译" class="headerlink" title="2.5 开始编译"></a>2.5 开始编译</h6><p>在llm&#x2F;llama.cpp文件夹下开始编译</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 创建build文件夹<br><span class="hljs-built_in">mkdir</span> build<br><br># 进入build文件夹<br><span class="hljs-built_in">cd</span> build<br><br># 构建<br># 生成构建配置，解析CMakeList.txt<br>cmake ..<br># 执行编译，最终在bin中生成可执行文件<br>cmake --build . --config Release<br></code></pre></td></tr></table></figure><p>最后得到的Release文件夹中的llama.quantize.exe就是我们用来量化模型可执行文件</p><h6 id="2-6-把safttensors转化为gguf文件"><a href="#2-6-把safttensors转化为gguf文件" class="headerlink" title="2.6 把safttensors转化为gguf文件"></a>2.6 把safttensors转化为gguf文件</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python convert_hf_to_gguf.py D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model <br></code></pre></td></tr></table></figure><p>查看文件夹，正确得到了gguf文件</p><h6 id="2-7-量化模型"><a href="#2-7-量化模型" class="headerlink" title="2.7 量化模型"></a>2.7 量化模型</h6><p>官方提供了多种量化格式，这里用的是Q4_K_M method</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># bin/Release/llama-quantize </span><br><span class="hljs-attribute">llama</span>-quantize D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model\deepseek-model-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>B-F16.gguf D:\Desktop\Doc\大四\毕设\DeepSeek\merged_model\deepseek-model-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>B-Q4_K_M.gguf Q4_K_M<br></code></pre></td></tr></table></figure><h6 id="2-8-创建Ollama模型"><a href="#2-8-创建Ollama模型" class="headerlink" title="2.8 创建Ollama模型"></a>2.8 创建Ollama模型</h6><p>创建ModelFile文件</p><p>创建模型</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ollama create deepseek-lora-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>b -f D:\Ollama\models\ModelFiles\deepseek-lora-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>b.Modelfile<br></code></pre></td></tr></table></figure><p>创建成功</p><h2 id="4-投喂PDF-观察效果"><a href="#4-投喂PDF-观察效果" class="headerlink" title="4.投喂PDF,观察效果"></a>4.投喂PDF,观察效果</h2>]]></content>
    
    
    
    <tags>
      
      <tag>毕设</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
